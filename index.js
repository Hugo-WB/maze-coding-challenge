/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Maze.ts":
/*!*********************!*\
  !*** ./src/Maze.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\r\nvar generator_1 = __webpack_require__(/*! ./generator */ \"./src/generator.ts\");\r\nvar Maze = /** @class */ (function () {\r\n    function Maze(width, height) {\r\n        this.start = {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        this.end = { x: 0, y: 0 };\r\n        this.phazors = [];\r\n        this.height = height !== null && height !== void 0 ? height : Math.floor(_1.canvas.height / (_1.CELL_WIDTH + _1.LINE_WIDTH));\r\n        this.width = width !== null && width !== void 0 ? width : Math.floor(_1.canvas.width / (_1.CELL_WIDTH + _1.LINE_WIDTH));\r\n        this.maze = generator_1.generateEllers(this.width, this.height);\r\n        this.end = {\r\n            x: Math.round(Math.random() * (this.width - 1)),\r\n            y: Math.round(Math.random() * (this.height - 1)),\r\n        };\r\n        for (var i = 0; i < Math.round((this.height * this.width) / 200); i++) {\r\n            this.phazors.push([\r\n                Math.round(Math.random() * (this.width - 1)),\r\n                Math.round(Math.random() * (this.height - 1)),\r\n            ]);\r\n        }\r\n    }\r\n    Maze.prototype.update = function () { };\r\n    Maze.prototype.draw = function () {\r\n        var pen = {\r\n            x: _1.LINE_WIDTH + _1.OFFSET.x,\r\n            y: _1.LINE_WIDTH + _1.OFFSET.y,\r\n        };\r\n        _1.ctx.fillStyle = \"red\";\r\n        _1.ctx.fillRect((this.end.x + 1) * _1.LINE_WIDTH + this.end.x * _1.CELL_WIDTH + _1.OFFSET.x, (this.end.y + 1) * _1.LINE_WIDTH + this.end.y * _1.CELL_WIDTH + _1.OFFSET.y, _1.CELL_WIDTH, _1.CELL_WIDTH);\r\n        _1.ctx.fillStyle = \"blue\";\r\n        this.phazors.forEach(function (phazor) {\r\n            _1.ctx.fillRect((phazor[0] + 1) * _1.LINE_WIDTH + phazor[0] * _1.CELL_WIDTH + _1.OFFSET.x, (phazor[1] + 1) * _1.LINE_WIDTH + phazor[1] * _1.CELL_WIDTH + _1.OFFSET.y, _1.CELL_WIDTH, _1.CELL_WIDTH);\r\n        });\r\n        _1.ctx.fillStyle = \"black\";\r\n        _1.ctx.beginPath();\r\n        var viewBox = {\r\n            x: [\r\n                Math.max(0, Math.round(0.9 * (-_1.OFFSET.x / _1.CELL_WIDTH))),\r\n                Math.min(this.width, Math.round(-_1.OFFSET.x / _1.CELL_WIDTH +\r\n                    2 * Math.floor(_1.canvas.width / (_1.CELL_WIDTH + _1.LINE_WIDTH) / 2) +\r\n                    2)),\r\n            ],\r\n            y: [\r\n                Math.max(0, Math.round((0.9 * -_1.OFFSET.y) / _1.CELL_WIDTH)),\r\n                Math.min(this.height, Math.round(-_1.OFFSET.y / _1.CELL_WIDTH) +\r\n                    2 * Math.floor(_1.canvas.height / (_1.CELL_WIDTH + _1.LINE_WIDTH) / 2) +\r\n                    2),\r\n            ],\r\n        };\r\n        for (var y = viewBox.y[0]; y < viewBox.y[1]; y++) {\r\n            pen.y = (y + 1) * _1.LINE_WIDTH + y * _1.CELL_WIDTH + _1.OFFSET.y;\r\n            for (var x = viewBox.x[0]; x < viewBox.x[1]; x++) {\r\n                pen.x = (x + 1) * _1.LINE_WIDTH + x * _1.CELL_WIDTH + _1.OFFSET.x;\r\n                _1.ctx.moveTo(pen.x, pen.y);\r\n                pen.x += _1.CELL_WIDTH;\r\n                if (this.maze[y][x].walls[0]) {\r\n                    _1.ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    _1.ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.y += _1.CELL_WIDTH;\r\n                if (this.maze[y][x].walls[1]) {\r\n                    _1.ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    _1.ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.x -= _1.CELL_WIDTH;\r\n                if (this.maze[y][x].walls[2]) {\r\n                    _1.ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    _1.ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.y -= _1.CELL_WIDTH;\r\n                if (this.maze[y][x].walls[3]) {\r\n                    _1.ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    _1.ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.x += _1.CELL_WIDTH;\r\n            }\r\n        }\r\n        _1.ctx.stroke();\r\n    };\r\n    return Maze;\r\n}());\r\nexports.default = Maze;\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/Maze.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar index_1 = __webpack_require__(/*! ./index */ \"./src/index.ts\");\r\nvar Maze_1 = __importDefault(__webpack_require__(/*! ./Maze */ \"./src/Maze.ts\"));\r\nvar Player = /** @class */ (function () {\r\n    function Player() {\r\n        this.phasing = false;\r\n        this.x = Math.round(index_1.canvas.width / 2);\r\n        this.y = Math.round(index_1.canvas.height / 2);\r\n        this.width = index_1.CELL_WIDTH / 2;\r\n        this.height = index_1.CELL_WIDTH / 2;\r\n    }\r\n    Player.prototype.getCurrentCoordinates = function () {\r\n        return {\r\n            x: Math.ceil((-index_1.OFFSET.x - index_1.LINE_WIDTH) / (index_1.LINE_WIDTH + index_1.CELL_WIDTH) +\r\n                Math.floor(index_1.canvas.width / (index_1.CELL_WIDTH + index_1.LINE_WIDTH) / 2)),\r\n            y: Math.round((-index_1.OFFSET.y - index_1.LINE_WIDTH) / (index_1.LINE_WIDTH + index_1.CELL_WIDTH)) +\r\n                Math.floor(index_1.canvas.height / (index_1.CELL_WIDTH + index_1.LINE_WIDTH) / 2),\r\n        };\r\n    };\r\n    Player.prototype.checkForColour = function (colour) {\r\n        var directions = [\r\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH / 2, this.y - (index_1.SPEED + 1), 1, 1),\r\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH + index_1.SPEED + 1, this.y + index_1.CELL_WIDTH / 2, 1, 1),\r\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH / 2, this.y + index_1.CELL_WIDTH + index_1.SPEED + 1, 1, 1),\r\n            index_1.ctx.getImageData(this.x - (index_1.SPEED + 1), this.y + index_1.CELL_WIDTH / 2, 1, 1),\r\n        ];\r\n        for (var i = 0; i < directions.length; i++) {\r\n            if (directions[i].data.toString() === colour) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Player.prototype.update = function () {\r\n        if (index_1.keys[\"w\"] || index_1.keys[\"ArrowUp\"]) {\r\n            if (!index_1.checkForWall(this.x, this.y, this.width, -index_1.SPEED) || this.phasing) {\r\n                index_1.OFFSET.y += index_1.SPEED;\r\n            }\r\n        }\r\n        if (index_1.keys[\"a\"] || index_1.keys[\"ArrowLeft\"]) {\r\n            if (!index_1.checkForWall(this.x, this.y, -index_1.SPEED, this.width) || this.phasing) {\r\n                index_1.OFFSET.x += index_1.SPEED;\r\n            }\r\n        }\r\n        if (index_1.keys[\"s\"] || index_1.keys[\"ArrowDown\"]) {\r\n            if (!index_1.checkForWall(this.x, this.y + this.width, this.width, index_1.SPEED) ||\r\n                this.phasing) {\r\n                index_1.OFFSET.y -= index_1.SPEED;\r\n            }\r\n        }\r\n        if (index_1.keys[\"d\"] || index_1.keys[\"ArrowRight\"]) {\r\n            if (!index_1.checkForWall(this.x + this.width, this.y, index_1.SPEED, this.width) ||\r\n                this.phasing) {\r\n                index_1.OFFSET.x -= index_1.SPEED;\r\n            }\r\n        }\r\n        // check if reached goal\r\n        if (this.checkForColour(\"255,0,0,255\")) {\r\n            index_1.showMenu();\r\n        }\r\n        // check if blue square\r\n        if (this.checkForColour(\"0,0,255,255\")) {\r\n            var maze = index_1.entities[1];\r\n            var coords = this.getCurrentCoordinates();\r\n            if (maze instanceof Maze_1.default) {\r\n                for (var i = 0; i < maze.phazors.length; i++) {\r\n                    if (Math.abs(maze.phazors[i][0] - coords.x) +\r\n                        Math.abs(maze.phazors[i][1] - coords.y) <\r\n                        4) {\r\n                        maze.phazors.splice(i, 1);\r\n                        // get screen offset for a random set of coordinates\r\n                        var offset = index_1.coordinatesToOffset(Math.round(Math.random() * (index_1.entities[1].width - 1)), Math.round(Math.random() * (index_1.entities[1].height - 1)));\r\n                        index_1.OFFSET.x = offset.x;\r\n                        index_1.OFFSET.y = offset.y;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (index_1.keys[\" \"]) {\r\n            this.phasing = true;\r\n        }\r\n        if (!index_1.keys[\" \"]) {\r\n            this.phasing = false;\r\n        }\r\n    };\r\n    Player.prototype.draw = function () {\r\n        index_1.ctx.fillRect(this.x, this.y, this.width, this.width);\r\n    };\r\n    return Player;\r\n}());\r\nexports.default = Player;\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/Player.ts?");

/***/ }),

/***/ "./src/generator.ts":
/*!**************************!*\
  !*** ./src/generator.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Cell = exports.generateEllers = void 0;\r\nvar Cell = /** @class */ (function () {\r\n    function Cell(set) {\r\n        this.walls = [true, true, true, true];\r\n        this.set = set;\r\n    }\r\n    return Cell;\r\n}());\r\nexports.Cell = Cell;\r\nvar createEmtpyRow = function (width) {\r\n    var row = [];\r\n    for (var x = 0; x < width; x++) {\r\n        row.push(new Cell(-1));\r\n    }\r\n    return row;\r\n};\r\nvar generateEllers = function (width, height) {\r\n    var setIndex = 0;\r\n    var sets = [];\r\n    var maze = [];\r\n    var row = [];\r\n    for (var x = 0; x < width; x++) {\r\n        row.push(new Cell(setIndex));\r\n        setIndex += 1;\r\n    }\r\n    for (var y = 0; y < height; y++) {\r\n        if (y == height - 1) {\r\n            for (var x = 1; x < width; x++) {\r\n                if (row[x].set != row[x - 1].set) {\r\n                    row[x].walls[3] = false;\r\n                    row[x - 1].walls[1] = false;\r\n                }\r\n            }\r\n            maze.push(row);\r\n            break;\r\n        }\r\n        for (var x = 1; x < width; x++) {\r\n            if (Math.random() < 0.5) {\r\n                row[x].set = row[x - 1].set;\r\n                row[x].walls[3] = false;\r\n                row[x - 1].walls[1] = false;\r\n            }\r\n        }\r\n        row.forEach(function (cell) {\r\n            if (!sets.includes(cell.set)) {\r\n                sets.push(cell.set);\r\n            }\r\n        });\r\n        var nextRow = createEmtpyRow(width);\r\n        if (y == height) {\r\n            sets = [];\r\n        }\r\n        while (sets.length > 0) {\r\n            for (var x = 0; x < width; x++) {\r\n                if (sets.includes(row[x].set)) {\r\n                    if (Math.random() < 0.3) {\r\n                        row[x].walls[2] = false;\r\n                        nextRow[x].walls[0] = false;\r\n                        nextRow[x].set = row[x].set;\r\n                        sets.splice(sets.indexOf(row[x].set), 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        nextRow = nextRow.map(function (cell) {\r\n            if (cell.set == -1) {\r\n                setIndex += 1;\r\n                cell.set = setIndex;\r\n            }\r\n            return cell;\r\n        });\r\n        maze.push(row);\r\n        row = nextRow;\r\n    }\r\n    return maze;\r\n};\r\nexports.generateEllers = generateEllers;\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/generator.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.coordinatesToOffset = exports.playing = exports.checkForWall = exports.entities = exports.showMenu = exports.keys = exports.SPEED = exports.OFFSET = exports.canvas = exports.ctx = exports.LINE_WIDTH = exports.CELL_WIDTH = void 0;\r\nvar Maze_1 = __importDefault(__webpack_require__(/*! ./Maze */ \"./src/Maze.ts\"));\r\nvar Player_1 = __importDefault(__webpack_require__(/*! ./Player */ \"./src/Player.ts\"));\r\nvar CELL_WIDTH = 40;\r\nexports.CELL_WIDTH = CELL_WIDTH;\r\nvar LINE_WIDTH = 1;\r\nexports.LINE_WIDTH = LINE_WIDTH;\r\nvar OFFSET = {\r\n    x: 0,\r\n    y: 0,\r\n};\r\nexports.OFFSET = OFFSET;\r\nvar SPEED = 8;\r\nexports.SPEED = SPEED;\r\nif (navigator.userAgent.indexOf(\"Chrome\") > -1) {\r\n    exports.SPEED = SPEED = 4;\r\n}\r\nvar playing = true;\r\nexports.playing = playing;\r\nvar canvas = document.getElementsByTagName(\"canvas\")[0];\r\nexports.canvas = canvas;\r\nvar nullAbleCTX = canvas.getContext(\"2d\");\r\nif (!(nullAbleCTX = canvas.getContext(\"2d\"))) {\r\n    throw new Error(\"2d context not supported\");\r\n}\r\nvar ctx = nullAbleCTX;\r\nexports.ctx = ctx;\r\nvar tempButton = document.getElementById(\"start\");\r\nif (tempButton == null) {\r\n    throw new Error(\"Render button first\");\r\n}\r\nvar button = tempButton;\r\nvar tempMenu = document.getElementById(\"afterMenu\");\r\nif (tempMenu == null) {\r\n    throw new Error(\"Render\");\r\n}\r\nvar menu = tempMenu;\r\nvar keys = {};\r\nexports.keys = keys;\r\nvar entities = [];\r\nexports.entities = entities;\r\nvar checkForWall = function (x, y, width, height) {\r\n    var pixels = ctx.getImageData(x, y, width, height).data;\r\n    for (var i = 0; i < pixels.length; i++) {\r\n        if (pixels[i] != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\nexports.checkForWall = checkForWall;\r\nvar coordinatesToOffset = function (x, y) {\r\n    return {\r\n        x: canvas.width / 2 - (x * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH),\r\n        y: canvas.height / 2 -\r\n            (y * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH) +\r\n            CELL_WIDTH / 3,\r\n    };\r\n};\r\nexports.coordinatesToOffset = coordinatesToOffset;\r\nvar animate = function () {\r\n    entities.forEach(function (entity) {\r\n        entity.update();\r\n    });\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    entities.forEach(function (entity) {\r\n        entity.draw();\r\n    });\r\n    if (playing) {\r\n        requestAnimationFrame(animate);\r\n    }\r\n};\r\nbutton.addEventListener(\"click\", function () {\r\n    button.style.visibility = \"hidden\";\r\n    animate();\r\n});\r\nvar showMenu = function () {\r\n    exports.playing = playing = false;\r\n    menu.style.visibility = \"visible\";\r\n};\r\nexports.showMenu = showMenu;\r\nmenu.addEventListener(\"click\", function () {\r\n    exports.OFFSET = OFFSET = { x: 0, y: 0 };\r\n    exports.entities = entities = [\r\n        new Player_1.default(),\r\n        new Maze_1.default(Math.round(entities[1].width * 1.2), Math.round(entities[1].height * 1.2)),\r\n    ];\r\n    menu.style.visibility = \"hidden\";\r\n    exports.playing = playing = true;\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    animate();\r\n});\r\nwindow.addEventListener(\"keydown\", function (e) {\r\n    keys[e.key] = true;\r\n});\r\nwindow.addEventListener(\"keyup\", function (e) {\r\n    keys[e.key] = false;\r\n});\r\nvar start = function () {\r\n    canvas.height = window.innerHeight;\r\n    canvas.width = window.innerWidth;\r\n    exports.entities = entities = [new Player_1.default(), new Maze_1.default()];\r\n    exports.OFFSET = OFFSET = { x: 0, y: 0 };\r\n};\r\nstart();\r\nvar background = new Maze_1.default();\r\nbackground.draw();\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/index.ts");
/******/ })()
;