/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/generator.ts":
/*!**************************!*\
  !*** ./src/generator.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Cell = exports.generateEllers = void 0;\r\nvar Cell = /** @class */ (function () {\r\n    function Cell(set) {\r\n        this.walls = [true, true, true, true];\r\n        this.set = set;\r\n    }\r\n    return Cell;\r\n}());\r\nexports.Cell = Cell;\r\nvar createEmtpyRow = function (width) {\r\n    var row = [];\r\n    for (var x = 0; x < width; x++) {\r\n        row.push(new Cell(-1));\r\n    }\r\n    return row;\r\n};\r\nvar generateEllers = function (width, height) {\r\n    var setIndex = 0;\r\n    var sets = [];\r\n    var maze = [];\r\n    var row = [];\r\n    for (var x = 0; x < width; x++) {\r\n        row.push(new Cell(setIndex));\r\n        setIndex += 1;\r\n    }\r\n    for (var y = 0; y < height; y++) {\r\n        if (y == height - 1) {\r\n            for (var x = 1; x < width; x++) {\r\n                if (row[x].set != row[x - 1].set) {\r\n                    row[x].walls[3] = false;\r\n                    row[x - 1].walls[1] = false;\r\n                }\r\n            }\r\n            maze.push(row);\r\n            break;\r\n        }\r\n        for (var x = 1; x < width; x++) {\r\n            if (Math.random() < 0.5) {\r\n                row[x].set = row[x - 1].set;\r\n                row[x].walls[3] = false;\r\n                row[x - 1].walls[1] = false;\r\n            }\r\n        }\r\n        row.forEach(function (cell) {\r\n            if (!sets.includes(cell.set)) {\r\n                sets.push(cell.set);\r\n            }\r\n        });\r\n        var nextRow = createEmtpyRow(width);\r\n        if (y == height) {\r\n            sets = [];\r\n        }\r\n        while (sets.length > 0) {\r\n            for (var x = 0; x < width; x++) {\r\n                if (sets.includes(row[x].set)) {\r\n                    if (Math.random() < 0.3) {\r\n                        row[x].walls[2] = false;\r\n                        nextRow[x].walls[0] = false;\r\n                        nextRow[x].set = row[x].set;\r\n                        sets.splice(sets.indexOf(row[x].set), 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        nextRow = nextRow.map(function (cell) {\r\n            if (cell.set == -1) {\r\n                setIndex += 1;\r\n                cell.set = setIndex;\r\n            }\r\n            return cell;\r\n        });\r\n        maze.push(row);\r\n        row = nextRow;\r\n    }\r\n    return maze;\r\n};\r\nexports.generateEllers = generateEllers;\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/generator.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar generator_1 = __webpack_require__(/*! ./generator */ \"./src/generator.ts\");\r\nvar CELL_WIDTH = 40;\r\nvar LINE_WIDTH = 1;\r\nvar OFFSET = {\r\n    x: 0,\r\n    y: 0,\r\n};\r\nvar SPEED = 8;\r\nif (navigator.userAgent.indexOf(\"Chrome\") > -1) {\r\n    SPEED = 4;\r\n}\r\nvar RUNNING = true;\r\nvar canvas = document.getElementsByTagName(\"canvas\")[0];\r\nvar nullAbleCTX = canvas.getContext(\"2d\");\r\nif (!(nullAbleCTX = canvas.getContext(\"2d\"))) {\r\n    throw new Error(\"2d context not supported\");\r\n}\r\nvar ctx = nullAbleCTX;\r\nvar tempButton = document.getElementById(\"start\");\r\nif (tempButton == null) {\r\n    throw new Error(\"Render button first\");\r\n}\r\nvar button = tempButton;\r\nvar tempMenu = document.getElementById(\"afterMenu\");\r\nif (tempMenu == null) {\r\n    throw new Error(\"Render\");\r\n}\r\nvar menu = tempMenu;\r\nvar keys = {};\r\nvar entities = [];\r\nvar checkForWall = function (x, y, width, height) {\r\n    var pixels = ctx.getImageData(x, y, width, height).data;\r\n    for (var i = 0; i < pixels.length; i++) {\r\n        if (pixels[i] != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\nvar coordinatesToOffset = function (x, y) {\r\n    return {\r\n        x: canvas.width / 2 - (x * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH),\r\n        y: canvas.height / 2 - (y * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH) + CELL_WIDTH / 3,\r\n    };\r\n};\r\nvar Player = /** @class */ (function () {\r\n    function Player() {\r\n        this.phasing = false;\r\n        this.x = Math.round(canvas.width / 2);\r\n        this.y = Math.round(canvas.height / 2);\r\n        this.width = CELL_WIDTH / 2;\r\n        this.height = CELL_WIDTH / 2;\r\n    }\r\n    Player.prototype.getCurrentCoordinates = function () {\r\n        return {\r\n            x: Math.ceil((-OFFSET.x - LINE_WIDTH) / (LINE_WIDTH + CELL_WIDTH) +\r\n                Math.floor(canvas.width / (CELL_WIDTH + LINE_WIDTH) / 2)),\r\n            y: Math.round((-OFFSET.y - LINE_WIDTH) / (LINE_WIDTH + CELL_WIDTH)) +\r\n                Math.floor(canvas.height / (CELL_WIDTH + LINE_WIDTH) / 2),\r\n        };\r\n    };\r\n    Player.prototype.checkForColour = function (colour) {\r\n        var directions = [\r\n            ctx.getImageData(this.x + CELL_WIDTH / 2, this.y - (SPEED + 1), 1, 1),\r\n            ctx.getImageData(this.x + CELL_WIDTH + SPEED + 1, this.y + CELL_WIDTH / 2, 1, 1),\r\n            ctx.getImageData(this.x + CELL_WIDTH / 2, this.y + CELL_WIDTH + SPEED + 1, 1, 1),\r\n            ctx.getImageData(this.x - (SPEED + 1), this.y + CELL_WIDTH / 2, 1, 1),\r\n        ];\r\n        for (var i = 0; i < directions.length; i++) {\r\n            if (directions[i].data.toString() === colour) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Player.prototype.update = function () {\r\n        if (keys[\"w\"] || keys[\"ArrowUp\"]) {\r\n            if (!checkForWall(this.x, this.y, this.width, -SPEED) || this.phasing) {\r\n                OFFSET.y += SPEED;\r\n            }\r\n        }\r\n        if (keys[\"a\"] || keys[\"ArrowLeft\"]) {\r\n            if (!checkForWall(this.x, this.y, -SPEED, this.width) || this.phasing) {\r\n                OFFSET.x += SPEED;\r\n            }\r\n        }\r\n        if (keys[\"s\"] || keys[\"ArrowDown\"]) {\r\n            if (!checkForWall(this.x, this.y + this.width, this.width, SPEED) ||\r\n                this.phasing) {\r\n                OFFSET.y -= SPEED;\r\n            }\r\n        }\r\n        if (keys[\"d\"] || keys[\"ArrowRight\"]) {\r\n            if (!checkForWall(this.x + this.width, this.y, SPEED, this.width) ||\r\n                this.phasing) {\r\n                OFFSET.x -= SPEED;\r\n            }\r\n        }\r\n        // check if reached goal\r\n        if (this.checkForColour(\"255,0,0,255\")) {\r\n            RUNNING = false;\r\n            showMenu();\r\n        }\r\n        // check if blue square\r\n        if (this.checkForColour(\"0,0,255,255\")) {\r\n            var maze = entities[1];\r\n            var coords = this.getCurrentCoordinates();\r\n            if (maze instanceof Maze) {\r\n                for (var i = 0; i < maze.phazors.length; i++) {\r\n                    if (Math.abs(maze.phazors[i][0] - coords.x) +\r\n                        Math.abs(maze.phazors[i][1] - coords.y) <\r\n                        4) {\r\n                        maze.phazors.splice(i, 1);\r\n                        // get screen offset for a random set of coordinates\r\n                        var offset = coordinatesToOffset(Math.round(Math.random() * (entities[1].width - 1)), Math.round(Math.random() * (entities[1].height - 1)));\r\n                        OFFSET.x = offset.x;\r\n                        OFFSET.y = offset.y;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (keys[\" \"]) {\r\n            this.phasing = true;\r\n        }\r\n        if (!keys[\" \"]) {\r\n            this.phasing = false;\r\n        }\r\n    };\r\n    Player.prototype.draw = function () {\r\n        ctx.fillRect(this.x, this.y, this.width, this.width);\r\n    };\r\n    return Player;\r\n}());\r\nvar Maze = /** @class */ (function () {\r\n    function Maze(width, height) {\r\n        this.start = {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        this.end = { x: 0, y: 0 };\r\n        this.phazors = [];\r\n        this.height = height !== null && height !== void 0 ? height : Math.floor(canvas.height / (CELL_WIDTH + LINE_WIDTH));\r\n        this.width = width !== null && width !== void 0 ? width : Math.floor(canvas.width / (CELL_WIDTH + LINE_WIDTH));\r\n        this.maze = generator_1.generateEllers(this.width, this.height);\r\n        this.end = {\r\n            x: Math.round(Math.random() * (this.width - 1)),\r\n            y: Math.round(Math.random() * (this.height - 1)),\r\n        };\r\n        for (var i = 0; i < Math.round((this.height * this.width) / 200); i++) {\r\n            this.phazors.push([\r\n                Math.round(Math.random() * (this.width - 1)),\r\n                Math.round(Math.random() * (this.height - 1)),\r\n            ]);\r\n        }\r\n    }\r\n    Maze.prototype.update = function () { };\r\n    Maze.prototype.draw = function () {\r\n        var pen = {\r\n            x: LINE_WIDTH + OFFSET.x,\r\n            y: LINE_WIDTH + OFFSET.y,\r\n        };\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect((this.end.x + 1) * LINE_WIDTH + this.end.x * CELL_WIDTH + OFFSET.x, (this.end.y + 1) * LINE_WIDTH + this.end.y * CELL_WIDTH + OFFSET.y, CELL_WIDTH, CELL_WIDTH);\r\n        ctx.fillStyle = \"blue\";\r\n        this.phazors.forEach(function (phazor) {\r\n            ctx.fillRect((phazor[0] + 1) * LINE_WIDTH + phazor[0] * CELL_WIDTH + OFFSET.x, (phazor[1] + 1) * LINE_WIDTH + phazor[1] * CELL_WIDTH + OFFSET.y, CELL_WIDTH, CELL_WIDTH);\r\n        });\r\n        ctx.fillStyle = \"black\";\r\n        ctx.beginPath();\r\n        var viewBox = {\r\n            x: [\r\n                Math.max(0, Math.round(0.9 * (-OFFSET.x / CELL_WIDTH))),\r\n                Math.min(this.width, Math.round(-OFFSET.x / CELL_WIDTH +\r\n                    2 * Math.floor(canvas.width / (CELL_WIDTH + LINE_WIDTH) / 2) +\r\n                    2)),\r\n            ],\r\n            y: [\r\n                Math.max(0, Math.round((0.9 * -OFFSET.y) / CELL_WIDTH)),\r\n                Math.min(this.height, Math.round(-OFFSET.y / CELL_WIDTH) +\r\n                    2 * Math.floor(canvas.height / (CELL_WIDTH + LINE_WIDTH) / 2) +\r\n                    2),\r\n            ],\r\n        };\r\n        for (var y = viewBox.y[0]; y < viewBox.y[1]; y++) {\r\n            pen.y = (y + 1) * LINE_WIDTH + y * CELL_WIDTH + OFFSET.y;\r\n            for (var x = viewBox.x[0]; x < viewBox.x[1]; x++) {\r\n                pen.x = (x + 1) * LINE_WIDTH + x * CELL_WIDTH + OFFSET.x;\r\n                ctx.moveTo(pen.x, pen.y);\r\n                pen.x += CELL_WIDTH;\r\n                if (this.maze[y][x].walls[0]) {\r\n                    ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.y += CELL_WIDTH;\r\n                if (this.maze[y][x].walls[1]) {\r\n                    ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.x -= CELL_WIDTH;\r\n                if (this.maze[y][x].walls[2]) {\r\n                    ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.y -= CELL_WIDTH;\r\n                if (this.maze[y][x].walls[3]) {\r\n                    ctx.lineTo(pen.x, pen.y);\r\n                }\r\n                else {\r\n                    ctx.moveTo(pen.x, pen.y);\r\n                }\r\n                pen.x += CELL_WIDTH;\r\n            }\r\n        }\r\n        ctx.stroke();\r\n    };\r\n    return Maze;\r\n}());\r\nvar animate = function () {\r\n    entities.forEach(function (entity) {\r\n        entity.update();\r\n    });\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    entities.forEach(function (entity) {\r\n        entity.draw();\r\n    });\r\n    if (RUNNING) {\r\n        requestAnimationFrame(animate);\r\n    }\r\n};\r\nbutton.addEventListener(\"click\", function () {\r\n    button.style.visibility = \"hidden\";\r\n    animate();\r\n});\r\nvar showMenu = function () {\r\n    menu.style.visibility = \"visible\";\r\n};\r\nmenu.addEventListener(\"click\", function () {\r\n    OFFSET = { x: 0, y: 0 };\r\n    entities = [\r\n        new Player(),\r\n        new Maze(Math.round(entities[1].width * 1.2), Math.round(entities[1].height * 1.2)),\r\n    ];\r\n    menu.style.visibility = \"hidden\";\r\n    RUNNING = true;\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    animate();\r\n});\r\nwindow.addEventListener(\"keydown\", function (e) {\r\n    keys[e.key] = true;\r\n});\r\nwindow.addEventListener(\"keyup\", function (e) {\r\n    keys[e.key] = false;\r\n});\r\nvar start = function () {\r\n    canvas.height = window.innerHeight;\r\n    canvas.width = window.innerWidth;\r\n    entities = [new Player(), new Maze()];\r\n    OFFSET = { x: 0, y: 0 };\r\n};\r\nstart();\r\nvar background = new Maze();\r\nbackground.draw();\r\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;