/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Maze.ts":
/*!*********************!*\
  !*** ./src/Maze.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nvar generator_1 = __webpack_require__(/*! ./generator */ \"./src/generator.ts\");\nvar Maze = /** @class */ (function () {\n    function Maze(width, height) {\n        this.start = {\n            x: 0,\n            y: 0,\n        };\n        this.end = { x: 0, y: 0 };\n        this.phazors = [];\n        // default maze height/width is the minimum to fill the screen\n        this.height = height !== null && height !== void 0 ? height : Math.floor(_1.canvas.height / (_1.CELL_WIDTH + _1.LINE_WIDTH));\n        this.width = width !== null && width !== void 0 ? width : Math.floor(_1.canvas.width / (_1.CELL_WIDTH + _1.LINE_WIDTH));\n        this.maze = generator_1.generateEllers(this.width, this.height);\n        // the goal is a random point\n        this.end = {\n            x: Math.round(Math.random() * (this.width - 1)),\n            y: Math.round(Math.random() * (this.height - 1)),\n        };\n        // randomly generate the blue squares/phazors\n        for (var i = 0; i < Math.round((this.height * this.width) / 200); i++) {\n            this.phazors.push([\n                Math.round(Math.random() * (this.width - 1)),\n                Math.round(Math.random() * (this.height - 1)),\n            ]);\n        }\n    }\n    Maze.prototype.update = function () { };\n    Maze.prototype.draw = function () {\n        // current location of the pen, used when drawing lines\n        var pen = {\n            x: _1.LINE_WIDTH + _1.OFFSET.x,\n            y: _1.LINE_WIDTH + _1.OFFSET.y,\n        };\n        // draw the goal\n        _1.ctx.fillStyle = \"red\";\n        _1.ctx.fillRect((this.end.x + 1) * _1.LINE_WIDTH + this.end.x * _1.CELL_WIDTH + _1.OFFSET.x, (this.end.y + 1) * _1.LINE_WIDTH + this.end.y * _1.CELL_WIDTH + _1.OFFSET.y, _1.CELL_WIDTH, _1.CELL_WIDTH);\n        // draw the phazors\n        _1.ctx.fillStyle = \"blue\";\n        this.phazors.forEach(function (phazor) {\n            _1.ctx.fillRect((phazor[0] + 1) * _1.LINE_WIDTH + phazor[0] * _1.CELL_WIDTH + _1.OFFSET.x, (phazor[1] + 1) * _1.LINE_WIDTH + phazor[1] * _1.CELL_WIDTH + _1.OFFSET.y, _1.CELL_WIDTH, _1.CELL_WIDTH);\n        });\n        _1.ctx.fillStyle = \"black\";\n        _1.ctx.beginPath();\n        // viewbox: used so that the maze only renders what is shown, otherwise it slows down the game a lot\n        var viewBox = {\n            x: [\n                Math.max(0, Math.round(0.9 * (-_1.OFFSET.x / _1.CELL_WIDTH))),\n                Math.min(this.width, Math.round(-_1.OFFSET.x / _1.CELL_WIDTH +\n                    2 * Math.floor(_1.canvas.width / (_1.CELL_WIDTH + _1.LINE_WIDTH) / 2) +\n                    2)),\n            ],\n            y: [\n                Math.max(0, Math.round((0.9 * -_1.OFFSET.y) / _1.CELL_WIDTH)),\n                Math.min(this.height, Math.round(-_1.OFFSET.y / _1.CELL_WIDTH) +\n                    2 * Math.floor(_1.canvas.height / (_1.CELL_WIDTH + _1.LINE_WIDTH) / 2) +\n                    2),\n            ],\n        };\n        for (var y = viewBox.y[0]; y < viewBox.y[1]; y++) {\n            pen.y = (y + 1) * _1.LINE_WIDTH + y * _1.CELL_WIDTH + _1.OFFSET.y;\n            for (var x = viewBox.x[0]; x < viewBox.x[1]; x++) {\n                pen.x = (x + 1) * _1.LINE_WIDTH + x * _1.CELL_WIDTH + _1.OFFSET.x;\n                _1.ctx.moveTo(pen.x, pen.y);\n                pen.x += _1.CELL_WIDTH;\n                // check for walls of the cell, and if there are walls, draw them\n                if (this.maze[y][x].walls[0]) {\n                    _1.ctx.lineTo(pen.x, pen.y);\n                }\n                else {\n                    _1.ctx.moveTo(pen.x, pen.y);\n                }\n                pen.y += _1.CELL_WIDTH;\n                if (this.maze[y][x].walls[1]) {\n                    _1.ctx.lineTo(pen.x, pen.y);\n                }\n                else {\n                    _1.ctx.moveTo(pen.x, pen.y);\n                }\n                pen.x -= _1.CELL_WIDTH;\n                if (this.maze[y][x].walls[2]) {\n                    _1.ctx.lineTo(pen.x, pen.y);\n                }\n                else {\n                    _1.ctx.moveTo(pen.x, pen.y);\n                }\n                pen.y -= _1.CELL_WIDTH;\n                if (this.maze[y][x].walls[3]) {\n                    _1.ctx.lineTo(pen.x, pen.y);\n                }\n                else {\n                    _1.ctx.moveTo(pen.x, pen.y);\n                }\n                pen.x += _1.CELL_WIDTH;\n            }\n        }\n        _1.ctx.stroke();\n    };\n    return Maze;\n}());\nexports.default = Maze;\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/Maze.ts?");

/***/ }),

/***/ "./src/Player.ts":
/*!***********************!*\
  !*** ./src/Player.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar index_1 = __webpack_require__(/*! ./index */ \"./src/index.ts\");\nvar Maze_1 = __importDefault(__webpack_require__(/*! ./Maze */ \"./src/Maze.ts\"));\nvar Player = /** @class */ (function () {\n    function Player() {\n        this.phasing = false;\n        this.x = Math.round(index_1.canvas.width / 2);\n        this.y = Math.round(index_1.canvas.height / 2);\n        this.width = index_1.CELL_WIDTH / 2;\n        this.height = index_1.CELL_WIDTH / 2;\n    }\n    Player.prototype.getCurrentCoordinates = function () {\n        // returns the current maze coordinates of the player\n        return {\n            x: Math.ceil((-index_1.OFFSET.x - index_1.LINE_WIDTH) / (index_1.LINE_WIDTH + index_1.CELL_WIDTH) +\n                Math.floor(index_1.canvas.width / (index_1.CELL_WIDTH + index_1.LINE_WIDTH) / 2)),\n            y: Math.round((-index_1.OFFSET.y - index_1.LINE_WIDTH) / (index_1.LINE_WIDTH + index_1.CELL_WIDTH)) +\n                Math.floor(index_1.canvas.height / (index_1.CELL_WIDTH + index_1.LINE_WIDTH) / 2),\n        };\n    };\n    Player.prototype.checkForColour = function (colour) {\n        // checks around the robot for the input colour\n        var directions = [\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH / 2, this.y - (index_1.SPEED + 1), 1, 1),\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH + index_1.SPEED + 1, this.y + index_1.CELL_WIDTH / 2, 1, 1),\n            index_1.ctx.getImageData(this.x + index_1.CELL_WIDTH / 2, this.y + index_1.CELL_WIDTH + index_1.SPEED + 1, 1, 1),\n            index_1.ctx.getImageData(this.x - (index_1.SPEED + 1), this.y + index_1.CELL_WIDTH / 2, 1, 1),\n        ];\n        for (var i = 0; i < directions.length; i++) {\n            if (directions[i].data.toString() === colour) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Player.prototype.update = function () {\n        var _this = this;\n        if (index_1.keys[\"w\"] || index_1.keys[\"ArrowUp\"]) {\n            if (!index_1.checkForWall(this.x, this.y, this.width, -index_1.SPEED) || this.phasing) {\n                index_1.OFFSET.y += index_1.SPEED;\n            }\n        }\n        if (index_1.keys[\"a\"] || index_1.keys[\"ArrowLeft\"]) {\n            if (!index_1.checkForWall(this.x, this.y, -index_1.SPEED, this.width) || this.phasing) {\n                index_1.OFFSET.x += index_1.SPEED;\n            }\n        }\n        if (index_1.keys[\"s\"] || index_1.keys[\"ArrowDown\"]) {\n            if (!index_1.checkForWall(this.x, this.y + this.width, this.width, index_1.SPEED) ||\n                this.phasing) {\n                index_1.OFFSET.y -= index_1.SPEED;\n            }\n        }\n        if (index_1.keys[\"d\"] || index_1.keys[\"ArrowRight\"]) {\n            if (!index_1.checkForWall(this.x + this.width, this.y, index_1.SPEED, this.width) ||\n                this.phasing) {\n                index_1.OFFSET.x -= index_1.SPEED;\n            }\n        }\n        // check if reached goal\n        if (this.checkForColour(\"255,0,0,255\")) {\n            index_1.showMenu();\n        }\n        // check if blue square\n        if (this.checkForColour(\"0,0,255,255\")) {\n            var maze = index_1.entities[1];\n            var coords = this.getCurrentCoordinates();\n            if (maze instanceof Maze_1.default) {\n                for (var i = 0; i < maze.phazors.length; i++) {\n                    // iterate through the phazors and find the one that we are next to\n                    if (Math.abs(maze.phazors[i][0] - coords.x) +\n                        Math.abs(maze.phazors[i][1] - coords.y) <\n                        4) {\n                        maze.phazors.splice(i, 1);\n                        // Teleporting to a random location:\n                        // get screen offset for a random set of coordinates\n                        var offset = index_1.coordinatesToOffset(Math.round(Math.random() * (index_1.entities[1].width - 1)), Math.round(Math.random() * (index_1.entities[1].height - 1)));\n                        index_1.OFFSET.x = offset.x;\n                        index_1.OFFSET.y = offset.y;\n                        // allow phasing for 1.5 seconds\n                        this.phasing = true;\n                        setTimeout(function () {\n                            _this.phasing = false;\n                        }, 1500);\n                        break;\n                    }\n                }\n            }\n        }\n        // 👀👀👀👀\n        if (index_1.keys[\"=\"]) {\n            this.phasing = true;\n        }\n        // if (!keys[\"=\"]) {\n        //   this.phasing = false;\n        // }\n    };\n    Player.prototype.draw = function () {\n        // draw the box in the middle of the screen\n        index_1.ctx.fillRect(this.x, this.y, this.width, this.width);\n    };\n    return Player;\n}());\nexports.default = Player;\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/Player.ts?");

/***/ }),

/***/ "./src/generator.ts":
/*!**************************!*\
  !*** ./src/generator.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cell = exports.generateEllers = void 0;\nvar Cell = /** @class */ (function () {\n    function Cell(set) {\n        this.walls = [true, true, true, true];\n        this.set = set;\n    }\n    return Cell;\n}());\nexports.Cell = Cell;\nvar createEmtpyRow = function (width) {\n    var row = [];\n    for (var x = 0; x < width; x++) {\n        row.push(new Cell(-1));\n    }\n    return row;\n};\nvar generateEllers = function (width, height) {\n    var setIndex = 0;\n    var sets = [];\n    var maze = [];\n    var row = [];\n    for (var x = 0; x < width; x++) {\n        row.push(new Cell(setIndex));\n        setIndex += 1;\n    }\n    for (var y = 0; y < height; y++) {\n        if (y == height - 1) {\n            for (var x = 1; x < width; x++) {\n                if (row[x].set != row[x - 1].set) {\n                    row[x].walls[3] = false;\n                    row[x - 1].walls[1] = false;\n                }\n            }\n            maze.push(row);\n            break;\n        }\n        for (var x = 1; x < width; x++) {\n            if (Math.random() < 0.5) {\n                row[x].set = row[x - 1].set;\n                row[x].walls[3] = false;\n                row[x - 1].walls[1] = false;\n            }\n        }\n        row.forEach(function (cell) {\n            if (!sets.includes(cell.set)) {\n                sets.push(cell.set);\n            }\n        });\n        var nextRow = createEmtpyRow(width);\n        if (y == height) {\n            sets = [];\n        }\n        while (sets.length > 0) {\n            for (var x = 0; x < width; x++) {\n                if (sets.includes(row[x].set)) {\n                    if (Math.random() < 0.3) {\n                        row[x].walls[2] = false;\n                        nextRow[x].walls[0] = false;\n                        nextRow[x].set = row[x].set;\n                        sets.splice(sets.indexOf(row[x].set), 1);\n                    }\n                }\n            }\n        }\n        nextRow = nextRow.map(function (cell) {\n            if (cell.set == -1) {\n                setIndex += 1;\n                cell.set = setIndex;\n            }\n            return cell;\n        });\n        maze.push(row);\n        row = nextRow;\n    }\n    return maze;\n};\nexports.generateEllers = generateEllers;\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/generator.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.coordinatesToOffset = exports.playing = exports.checkForWall = exports.entities = exports.showMenu = exports.keys = exports.SPEED = exports.OFFSET = exports.canvas = exports.ctx = exports.LINE_WIDTH = exports.CELL_WIDTH = void 0;\nvar Maze_1 = __importDefault(__webpack_require__(/*! ./Maze */ \"./src/Maze.ts\"));\nvar Player_1 = __importDefault(__webpack_require__(/*! ./Player */ \"./src/Player.ts\"));\nconsole.log(\"Cheat: Press = to phase through walls\");\nvar CELL_WIDTH = 40;\nexports.CELL_WIDTH = CELL_WIDTH;\nvar LINE_WIDTH = 1;\nexports.LINE_WIDTH = LINE_WIDTH;\nvar OFFSET = {\n    x: 0,\n    y: 0,\n};\nexports.OFFSET = OFFSET;\nvar SPEED = 4;\nexports.SPEED = SPEED;\nif (navigator.userAgent.indexOf(\"Firefox\") > -1) {\n    exports.SPEED = SPEED = 8;\n}\nvar playing = true;\nexports.playing = playing;\n// HTML ELements:\nvar canvas = document.getElementsByTagName(\"canvas\")[0];\nexports.canvas = canvas;\nvar nullAbleCTX = canvas.getContext(\"2d\");\nif (!(nullAbleCTX = canvas.getContext(\"2d\"))) {\n    throw new Error(\"2d context not supported\");\n}\nvar ctx = nullAbleCTX;\nexports.ctx = ctx;\nvar tempButton = document.getElementById(\"start\");\nif (tempButton == null) {\n    throw new Error(\"Render button first\");\n}\nvar button = tempButton;\nvar tempMenu = document.getElementById(\"afterMenu\");\nif (tempMenu == null) {\n    throw new Error(\"Render\");\n}\nvar menu = tempMenu;\n// dictionary of keys pressed, when pressed the key's value will be true\nvar keys = {};\nexports.keys = keys;\nvar entities = [];\nexports.entities = entities;\n// helper functions:\nvar checkForWall = function (x, y, width, height) {\n    // checks in defined area if there are non-white pixels in the area\n    var pixels = ctx.getImageData(x, y, width, height).data;\n    for (var i = 0; i < pixels.length; i++) {\n        if (pixels[i] != 0) {\n            return true;\n        }\n    }\n    return false;\n};\nexports.checkForWall = checkForWall;\nvar coordinatesToOffset = function (x, y) {\n    // converts maze coordinates to the offset needed to center that maze cell\n    // E.g. Used for teleporting, so that the screen centers on a random cell\n    return {\n        x: canvas.width / 2 - (x * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH),\n        y: canvas.height / 2 -\n            (y * (LINE_WIDTH + CELL_WIDTH) + LINE_WIDTH) +\n            CELL_WIDTH / 3,\n    };\n};\nexports.coordinatesToOffset = coordinatesToOffset;\nvar animate = function () {\n    // main animation loop\n    entities.forEach(function (entity) {\n        entity.update();\n    });\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    entities.forEach(function (entity) {\n        entity.draw();\n    });\n    if (playing) {\n        requestAnimationFrame(animate);\n    }\n};\nbutton.addEventListener(\"click\", function () {\n    // check for game start\n    button.style.visibility = \"hidden\";\n    animate();\n});\nvar showMenu = function () {\n    exports.playing = playing = false;\n    menu.style.visibility = \"visible\";\n};\nexports.showMenu = showMenu;\nmenu.addEventListener(\"click\", function () {\n    // continue game with a slightly larger maze\n    exports.OFFSET = OFFSET = { x: 0, y: 0 };\n    exports.entities = entities = [\n        new Player_1.default(),\n        new Maze_1.default(Math.round(entities[1].width * 1.3), Math.round(entities[1].height * 1.3)),\n    ];\n    menu.style.visibility = \"hidden\";\n    exports.playing = playing = true;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    animate();\n});\nwindow.addEventListener(\"keydown\", function (e) {\n    keys[e.key] = true;\n});\nwindow.addEventListener(\"keyup\", function (e) {\n    keys[e.key] = false;\n});\nvar start = function () {\n    canvas.height = window.innerHeight;\n    canvas.width = window.innerWidth;\n    exports.entities = entities = [new Player_1.default(), new Maze_1.default()];\n    exports.OFFSET = OFFSET = { x: 0, y: 0 };\n};\nstart();\nvar background = new Maze_1.default();\nbackground.draw();\n\n\n//# sourceURL=webpack://maze-coding-challenge/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/index.ts");
/******/ })()
;